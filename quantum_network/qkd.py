# quantum_network/qkd.py

import numpy as np
import random

class QuantumKeyDistribution:
    def __init__(self, sender_id: str, receiver_id: str):
        """
        Initialize the Quantum Key Distribution (QKD) system.

        Args:
            sender_id (str): Unique identifier for the sender.
            receiver_id (str): Unique identifier for the receiver.
        """
        self.sender_id = sender_id
        self.receiver_id = receiver_id
        self.key_length = 8  # Length of the key to be generated
        self.sender_bits = []  # Bits generated by the sender
        self.sender_bases = []  # Bases used by the sender
        self.receiver_bits = []  # Bits received by the receiver
        self.receiver_bases = []  # Bases used by the receiver
        self.shared_key = []  # Final shared key

    def generate_bits(self):
        """
        Generate random bits and bases for the sender.
        """
        self.sender_bits = [random.randint(0, 1) for _ in range(self.key_length)]
        self.sender_bases = [random.choice(['+','x']) for _ in range(self.key_length)]
        print(f"{self.sender_id}: Generated bits {self.sender_bits} with bases {self.sender_bases}.")

    def encode_bits(self):
        """
        Encode the bits into quantum states based on the chosen bases.
        """
        encoded_states = []
        for bit, base in zip(self.sender_bits, self.sender_bases):
            if base == '+':
                # Encode in the standard basis
                encoded_states.append(0 if bit == 0 else 1)  # 0 -> |0>, 1 -> |1>
            else:
                # Encode in the diagonal basis
                encoded_states.append(2 if bit == 0 else 3)  # 0 -> |+>, 1 -> |->

        print(f"{self.sender_id}: Encoded states {encoded_states}.")
        return encoded_states

    def transmit(self, encoded_states):
        """
        Simulate the transmission of encoded states to the receiver.
        """
        print(f"{self.sender_id}: Transmitting encoded states to {self.receiver_id}.")
        self.receiver_receive(encoded_states)

    def receiver_receive(self, encoded_states):
        """
        Simulate the receiver's measurement of the transmitted states.
        """
        self.receiver_bases = [random.choice(['+','x']) for _ in range(self.key_length)]
        print(f"{self.receiver_id}: Chose bases {self.receiver_bases} for measurement.")

        for state, base in zip(encoded_states, self.receiver_bases):
            if base == '+':
                # Measure in the standard basis
                self.receiver_bits.append(state)  # Directly measure the state
            else:
                # Measure in the diagonal basis
                if state in [2, 3]:  # |+> or |-> states
                    self.receiver_bits.append(1 if state == 2 else 0)  # |+> -> 1, |-> -> 0
                else:
                    self.receiver_bits.append(state)  # |0> or |1> states remain unchanged

        print(f"{self.receiver_id}: Received bits {self.receiver_bits}.")

    def sift_key(self):
        """
        Sift the key by comparing bases and keeping only the bits measured with the same basis.
        """
        for sender_base, receiver_base, sender_bit, receiver_bit in zip(self.sender_bases, self.receiver_bases, self.sender_bits, self.receiver_bits):
            if sender_base == receiver_base:
                self.shared_key.append(receiver_bit)

        print(f"Shared key after sifting: {self.shared_key}")

# Example usage
if __name__ == "__main__":
    qkd = QuantumKeyDistribution(sender_id="Alice", receiver_id="Bob")
    
    # Generate bits and encode them
    qkd.generate_bits()
    encoded_states = qkd.encode_bits()
    
    # Transmit the encoded states
    qkd.transmit(encoded_states)
    
    # Sift the key
    qkd.sift_key()
